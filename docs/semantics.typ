#import "@local/utils:0.1.0": *
#show: doc.with(title: [ATL Semantics])
//============================================================================//

= Definitions

- System $F_omega^mu$
- Haskell Typeclasses
- Largely based on Pierce's definitions.

Definition. Let *ATLCore* be the language generated by the following rules.
#bnf(
  // Prod($"`Decl"$, annot: [_top-level_], {
  //   Or[$"`Decl in Decl"$][]
  //   Or[$"`let x:T = t"$][_top-level definition_]
  //   Or[$"`data X::K DParams where DCons"$][_top-level data type definition_]
  //   Or[$"`class C CParams where CCons"$][_class abstraction_]
  //   Or[$"`instance C IParams where ICons"$][_class instance_]
  // }),
  // Prod($"`DParams"$, {
  //   Or[$"t"$][]
  // }),
  Prod($"`t"$, annot: [_terms_], {
    Or[$"`x"$][_variable_]
    Or[$lambda"`x:T.t"$][_abstraction_]
    Or[$"`t t"$][_application_]
    Or[$lambda"`X::K.t"$][_type abstraction_]
    Or[$"`t T"$][_type application_]
    // Or[$"`class r X"_i"`::K"_i"` R.t"$][_class_]
    // Or[$"`instance r T"_i space^(i in 1..n) space "`t.t"$][_instance_]
    // Or[${"*`T","`t"}"` as T"$][_packing_]
    // Or[$"`let "{"`X,x"}="`t in t"$][_unpacking_]
    Or[$"`fold T t"$][_folding_]
    Or[$"`unfold T t"$][_unfolding_]
    // Or[$"`{l"_i="`t"_i space^(i in 1..n) "`}"$][_record_]
    // Or[$"`t.l"$][_projection_]
    Or[$angle.l"`C c"_i space^(i in 1..n) angle.r$][_construct_]
    Or[$"`case t of" angle.l"`C"_i "` c"_(i j) space^(j in 1..m) angle.r => "`t"_i space^(i in 1..n)$][_case_]
  }),
  Prod($"`T"$, annot: [_types_], {
    Or[$"`X"$][_type variable_]
    Or[$"`T" -> "`T"$][_type of functions_]
    Or[$angle.l "`C"_i "`:T"_i space^(i in 1..n) angle.r$][_type of constructs_]
    Or[$mu"`X.T"$][_recursive type_]
    Or[$forall"`X::K.T"$][_universal type_]
    // Or[${exists"`X::K","`T"}$][_existential type_]
    Or[$lambda"`X::K.T"$][_operator abstraction_]
    Or[$"`T T"$][_operator application_]
    Or[$"`case T of T"_i => "`T"_i space^(i in 1..n)$][_type mapping_]
    // Or[$"`R" => "`T"$][_type constraint_]
    // Or[$exists"`r.x:T as x" => "`T"$][_term constraint_]
    // Or[$exists"`r.X::K as X" => "`T"$][_type constraint_]
    Or[$"`r T"_i space^(i in 1..n) => "`T"$][_type constraint_]
  }),
  Prod($"`K"$, annot: [_kinds_], {
    Or[$star$][_kind of proper types_]
    Or[$"`K" => "`K"$][_kind of operators_]
  }),
  Prod($"`c"$, annot: [_fields_], {
    Or[$"`t"$][_term field_]
    Or[$"`T"$][_type field_]
  }),
  Prod($"`R"$, annot: [_classes_], {
    Or[$exists"`x:T.R"$][_term requirement_]
    Or[$exists"`X::K.R"$][_type requirement_]
    Or[$top$][_empty requirement_]
  }),
  Prod($"`I"$, annot: [_instances_], {
    Or[$"`x = t.R"$][_term fulfillment_]
    Or[$"`X = T.R"$][_type fulfillment_]
    Or[$top$][_empty fulfillment_]
  }),
)

// and the following top-level rules.
// #bnf(
//   Prod($"`M"$, annot: [_top-level_], {
//     Or[$"`let x:T = t"$][_top-level term_]
//     Or[$"`let X::K = T"$][_top-level type_]
//     Or[$"`data X X"_i"`::K"_i space^(i in 1..n) "` where C"_j"`:T"_j space^(j in 1..n)$][_data type_]
//     Or[$"`class r X"_i"`::K"_i space^(i in 1..n) "`where"
//     "`X"_j"`::K"_j space^(j in 1..m) quad
//     "`x"_k"`:T"_k space^(k in 1..h)$][_type class_]
//   }),
// )

Definition. Let the following ATLCore terms be called *values*.
#bnf(
  Prod($"`v"$, annot: [_values_], {
    Or[$lambda"`x:T.t"$][_abstraction_]
    Or[$lambda"`X::K.t"$][_type abstraction_]
    // Or[${"*`T","`v"}"` as T"$][_packing_]
    Or[$"`fold [T] v"$][_folding_]
    Or[$angle.l"`C cv"_i space^(i in 1..n) angle.r$][_construct_]
  }),
  Prod($"`cv"$, annot: [_field values_], {
    Or[$"`v"$][_term value_]
    Or[$"`T"$][_type_]
  }),
)

Definition. Let the context $Gamma$ be a set of elements of the following forms.
#bnf(Prod($Gamma$, annot: [_contexts_], {
  Or[$"`x:T"$][_term variable binding_]
  Or[$"`X::K"$][_type variable binding_]
  Or[$"`%X"$][_new type binding_]
}))

Definition. Let the ATLCore *one-step evaluation* relation ($-->$) be the smallest binary relation on terms satisfying the following inference rules.

$
  #prooftree(rule(
    $"`if" "`t"_1 "`then" "`t"_2 "`else" "`t"_3 --> "`if" "`t"_1 "`then" "`t"'_2 "`else" "`t"_3$,
    $"`t"_2 --> "`t"'_2$,
  ))
$

// Definition. Let $"`t""-->*""`t'"$ denote that $("`t","`t'")$ is an element of the transitive-reflexive closure of the one-step evaluation relation.

Definition. Let the ATLCore *typing* relation be the smallest binary relation between terms and types satisfying the following inference rules.

$
  #prooftree(rule($...:...$, $...$))
$

Definition. Let the ATLCore *term ordering* relation be ....

$
  #prooftree(rule($...:...$, $...$))
$


//============================================================================//

= Properties

*Summary:*
- Inversion Lemmas
- Turing Completeness
- Type Progress Theorem
- Type Preservation Theorem

== Evaluation Properties

#theorem("2.1.1", [
  For all terms $"`t","`t'"$ and $"`t''"$, if $"`t"-->"`t'"$ and $"`t"-->"`t''"$, then $"`t'"="`t''"$.
])

Proof. ...

#theorem("2.1.2", [
  // inversion lemma.
  ...
])

Proof. ...


== Typing Properties

#theorem("2.2.1", [
  // type determinacy
  ...
])

Proof. ...

#theorem("2.2.2", [
  // inversion lemma.
  ...
])

Proof. ...

//============================================================================//

= Derived Forms

//============================================================================//

= Complete Language Definition

//============================================================================//

= Examples


//============================================================================//
